defmodule BinPacker.Diff do
  @moduledoc """
  A Diff indicates the changes between one bin_packer and another, as generated by PartitionMap.diff/2.

  The differences are presented by the following attributes:

  `:added_bins`, the bins that were added
  `:removed_bins`, the bins that were removed
  `:added_balls`, the balls that were added
  `:removed_balls`, the balls that were removed
  `:moved_balls`, a list of ball Move structs inidicating how balls moved from one bin to another
  """

  alias BinPacker, as: BinPacker
  alias BinPacker.Assignments
  alias BinPacker.Bin

  defstruct [
    :cost_change,
    added_bins: [],
    removed_bins: [],
    added_balls: [],
    removed_balls: [],
    ball_moves: []
  ]

  @type ball_moves :: [BallMove.t()]

  # @type t :: %__MODULE__{
  #   cost_change: BinPacker.cost,
  #   added_bins: BinPacker.bins,
  #   removed_bins: BinPacker.bins,
  #   added_balls: BinPacker.balls,
  #   removed_balls: BinPacker.balls,
  #   ball_moves: ball_moves
  # }

  defmodule BallMove do
    @moduledoc """
    Describes how a ball moved from one bin to another.
    """

    defstruct [:ball, :from_bin, :to_bin]

    # @type t :: %__MODULE__{
    #   ball: BinPacker.ball,
    #   from_bin: BinPacker.bin,
    #   to_bin: BinPacker.bin
    # }
  end

  # @spec diff(BinPacker.t, BinPacker.t) :: t
  def diff(%BinPacker{} = bin_packer, %BinPacker{} = other_bin_packer) do
    cost = BinPacker.cost(bin_packer)
    other_cost = BinPacker.cost(other_bin_packer)

    cost_change = other_cost - cost

    bin_ids = bin_packer |> Assignments.bin_ids() |> MapSet.new()
    other_bin_ids = other_bin_packer |> Assignments.bin_ids() |> MapSet.new()

    added_bins =
      other_bin_ids
      |> MapSet.difference(bin_ids)
      |> MapSet.to_list()
      |> ids_to_bins(other_bin_packer)

    removed_bins =
      bin_ids
      |> MapSet.difference(other_bin_ids)
      |> MapSet.to_list()
      |> ids_to_bins(bin_packer)

    ball_ids = bin_packer |> Assignments.ball_ids() |> MapSet.new()
    other_ball_ids = other_bin_packer |> Assignments.ball_ids() |> MapSet.new()

    added_balls =
      other_ball_ids
      |> MapSet.difference(ball_ids)
      |> MapSet.to_list()
      |> group_by_node(other_bin_packer)

    removed_balls =
      ball_ids
      |> MapSet.difference(other_ball_ids)
      |> MapSet.to_list()
      |> group_by_node(bin_packer)

    ball_moves =
      ball_ids
      |> MapSet.intersection(other_ball_ids)
      |> Enum.map(fn ball_id ->
        ball = Assignments.get_ball(other_bin_packer, ball_id)
        from_bin = Assignments.bin_for_ball_id(bin_packer, ball_id)
        to_bin = Assignments.bin_for_ball_id(other_bin_packer, ball_id)

        %BallMove{ball: ball, from_bin: from_bin, to_bin: to_bin}
      end)
      |> Enum.reject(fn %BallMove{from_bin: from_bin, to_bin: to_bin} ->
        Bin.id(from_bin) == Bin.id(to_bin)
      end)

    %__MODULE__{
      cost_change: cost_change,
      added_bins: added_bins,
      removed_bins: removed_bins,
      added_balls: added_balls,
      removed_balls: removed_balls,
      ball_moves: ball_moves
    }
  end

  defp ids_to_bins(ids, %BinPacker{} = packer) do
    Enum.map(ids, &Assignments.get_bin(packer, &1))
  end

  defp group_by_node(ids, %BinPacker{} = packer) do
    ids
    |> Enum.map(&Assignments.get_ball(packer, &1))
    |> Enum.group_by(&Assignments.bin_for_ball(packer, &1))
  end
end
